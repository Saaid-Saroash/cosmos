cd $env:USERPROFILE\Downloads
python .\insta.py -s "65860131821%3AWA3kMGqxMpJg4j%3A27%3AAYifil4vt52fcCoIGXQVuKnzdwD7d9i91OIg4_YwJg" -u saaid_sarosh77

python app.py
___________________________________________________________________________________________________________________________________
pip install requests
cd $env:USERPROFILE\Downloads
python -m venv venv
.\venv\Scripts\Activate.ps1
pip install requests
pip install flask

APP.PY
________________________________________________________________________________________________________________________________________
#!/usr/bin/env python3
"""
Combined Flask + CLI Instagram follower/following tracker.
- Run as web server (default): python app.py
- Run CLI one-shot: python app.py --cli -s SESSIONID -u username
- Run CLI watch mode: python app.py --cli -s SESSIONID -u username --watch 300

Outputs:
 - Serves a simple HTML UI at GET / (templates/index.html)
 - POST /track accepts form-data: sessionid, username, user_id and returns JSON with:
   followers, followings, followers_data, followings_data, added/removed lists since last snapshot.
"""
import argparse
import json
import os
import sys
import time
from typing import Dict, Optional, Tuple, Set

import requests
from flask import Flask, render_template, request, jsonify

# ----- Configuration -----
USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/124.0.0.0 Safari/537.36"
)
APP_ID = "936619743392459"
TIMEOUT = 15
PAGE_SIZE = 200
RATE_SLEEP = 1.0  # seconds between pages
SNAPSHOT_DIR = "snapshots"
if not os.path.exists(SNAPSHOT_DIR):
    os.makedirs(SNAPSHOT_DIR)

# ----- Flask app -----
app = Flask(__name__, template_folder="templates")


def build_session(sessionid: str) -> requests.Session:
    s = requests.Session()
    s.headers.update({
        "User-Agent": USER_AGENT,
        "Referer": "https://www.instagram.com/",
        "X-IG-App-ID": APP_ID,
        "Accept": "/",
        "Accept-Language": "en-US,en;q=0.9",
    })
    # set cookie (authenticated session)
    s.cookies.set("sessionid", sessionid, domain=".instagram.com")
    return s


def resolve_userid(session: requests.Session, username: Optional[str], userid: Optional[str]) -> Optional[Tuple[str, str]]:
    """
    Returns (user_id, canonical_username) or None.
    Tries i.instagram.com web_profile_info first then public JSON fallback.
    """
    if username:
        url = f"https://i.instagram.com/api/v1/users/web_profile_info/?username={username}"
        try:
            r = session.get(url, timeout=TIMEOUT)
            if r.status_code == 200:
                data = r.json()
                user = data.get("data", {}).get("user") or data.get("user")
                if user and ("pk" in user or "id" in user):
                    uid = str(user.get("pk") or user.get("id"))
                    uname = user.get("username") or username
                    return uid, uname
        except Exception:
            pass
        # fallback: public page json
        try:
            r2 = session.get(f"https://www.instagram.com/{username}/?__a=1", timeout=TIMEOUT)
            if r2.status_code == 200:
                js = r2.json()
                user = js.get("graphql", {}).get("user") or js.get("user")
                if user and ("id" in user):
                    return str(user["id"]), user.get("username", username)
        except Exception:
            pass
        return None

    if userid:
        # try i.instagram.com info endpoint
        try:
            r = session.get(f"https://i.instagram.com/api/v1/users/{userid}/info/", timeout=TIMEOUT)
            if r.status_code == 200:
                js = r.json()
                u = js.get("user")
                if u and ("username" in u):
                    return str(userid), u.get("username")
        except Exception:
            pass
        # last resort: accept numeric id and use as username placeholder
        return str(userid), str(userid)

    return None


def fetch_relationship_data(session: requests.Session, user_id: str, relationship: str) -> Optional[Dict[str, Dict]]:
    """
    relationship: "followers" or "following" (followings)
    Returns dict mapping user_id -> {username, full_name, profile_pic_url}
    """
    data = {}
    assert relationship in ("followers", "following", "followings", "followed-by")
    # use expected endpoint shape
    endpoint_name = "followers" if relationship.startswith("follower") else "following"
    url_template = f"https://i.instagram.com/api/v1/friendships/{user_id}/{endpoint_name}/?count={PAGE_SIZE}"
    next_max_id = None
    tries = 0

    while True:
        tries += 1
        url = url_template + (f"&max_id={next_max_id}" if next_max_id else "")
        try:
            r = session.get(url, timeout=TIMEOUT)
        except Exception as e:
            print(f"Network error fetching {relationship}: {e}")
            return None

        if r.status_code == 200:
            try:
                js = r.json()
            except ValueError:
                print("Non-JSON response while fetching relationships.")
                return None

            users = js.get("users") or js.get("items") or []
            for u in users:
                pk = str(u.get("pk") or u.get("id"))
                data[pk] = {
                    "username": u.get("username"),
                    "full_name": u.get("full_name") or "",
                    "profile_pic_url": u.get("profile_pic_url") or u.get("profile_pic_url_hd") or "",
                }

            # pagination tokens vary between endpoints
            next_max_id = js.get("next_max_id") or js.get("next_cursor") or js.get("next_max_id")
            more_available = js.get("more_available") or js.get("more")
            if not next_max_id and not more_available:
                break

            if not users:
                break

            time.sleep(RATE_SLEEP)

        elif r.status_code == 429:
            print("Rate limited (429). Back off and try later.")
            return None
        else:
            print(f"Failed to fetch {relationship} (HTTP {r.status_code}).")
            return None

        if tries > 500:
            print("Too many pages, aborting.")
            break

    return data


def snapshot_filename(kind: str, target_uid: str) -> str:
    # kind = 'followers' or 'followings'
    return os.path.join(SNAPSHOT_DIR, f"{kind}_{target_uid}.json")


def load_snapshot(filename: str) -> Dict[str, Dict]:
    if not os.path.exists(filename):
        return {}
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def save_snapshot(data: Dict[str, Dict], filename: str):
    try:
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"Failed to save snapshot {filename}: {e}")


def diff_sets(old: Dict[str, Dict], new: Dict[str, Dict]):
    old_set = set(old.keys())
    new_set = set(new.keys())
    added = sorted(list(new_set - old_set))
    removed = sorted(list(old_set - new_set))
    return added, removed


# --- Flask routes ---
@app.route("/")
def index():
    return render_template("index.html")


@app.route("/track", methods=["POST"])
def track():
    sessionid = request.form.get("sessionid")
    username = request.form.get("username")
    user_id = request.form.get("user_id")

    if not sessionid:
        return jsonify({"error": "Session ID is required"}), 400
    if not username and not user_id:
        return jsonify({"error": "Provide either username or user_id"}), 400

    session = build_session(sessionid)
    resolved = resolve_userid(session, username, user_id)
    if not resolved:
        return jsonify({"error": "Could not resolve user (check username/id or session permissions)"}), 400

    target_uid, canonical_username = resolved

    followers = fetch_relationship_data(session, target_uid, "followers")
    followings = fetch_relationship_data(session, target_uid, "following")

    if followers is None or followings is None:
        return jsonify({"error": "Failed to fetch data (possibly rate-limited or invalid session)"}), 500

    # load previous snapshots to compute diff
    followers_file = snapshot_filename("followers", target_uid)
    followings_file = snapshot_filename("followings", target_uid)
    old_followers = load_snapshot(followers_file)
    old_followings = load_snapshot(followings_file)

    added_followers, removed_followers = diff_sets(old_followers, followers)
    added_followings, removed_followings = diff_sets(old_followings, followings)

    # save new snapshots
    save_snapshot(followers, followers_file)
    save_snapshot(followings, followings_file)

    # build compact diff info
    def compact(list_ids, src):
        return [{"id": i, "username": src.get(i, {}).get("username"), "full_name": src.get(i, {}).get("full_name")} for i in list_ids]

    return jsonify({
        "username": canonical_username,
        "user_id": target_uid,
        "followers": len(followers),
        "followings": len(followings),
        "followers_data": followers,
        "followings_data": followings,
        "diff": {
            "followers_added": compact(added_followers, followers),
            "followers_removed": compact(removed_followers, old_followers),
            "followings_added": compact(added_followings, followings),
            "followings_removed": compact(removed_followings, old_followings)
        }
    })


# --- CLI utilities (reuse above functions) ---
def print_changes(added: Set[str], removed: Set[str], old: Dict[str, Dict], new: Dict[str, Dict]):
    if not added and not removed:
        print("No changes since last snapshot.")
        return
    if added:
        print(f"\n➕ New ({len(added)}):")
        for pk in sorted(added):
            info = new.get(pk, {})
            print(f"  - {info.get('username') or '(unknown)'} (id: {pk}) {info.get('full_name') or ''}")
    if removed:
        print(f"\n➖ Removed ({len(removed)}):")
        for pk in sorted(removed):
            info = old.get(pk, {})
            print(f"  - {info.get('username') or '(unknown)'} (id: {pk}) {info.get('full_name') or ''}")


def run_once_cli(sessionid: str, username: Optional[str], userid: Optional[str], snapshot_prefix: Optional[str] = None):
    session = build_session(sessionid)
    resolved = resolve_userid(session, username, userid)
    if not resolved:
        print("Could not resolve target account. Check username/id and session permissions.")
        return
    target_uid, canonical_username = resolved
    print(f"Fetching for {canonical_username} (id {target_uid}) ...")

    followers = fetch_relationship_data(session, target_uid, "followers")
    followings = fetch_relationship_data(session, target_uid, "following")
    if followers is None or followings is None:
        print("Failed to fetch (rate-limited/invalid session).")
        return

    followers_file = snapshot_filename("followers", target_uid)
    followings_file = snapshot_filename("followings", target_uid)
    old_followers = load_snapshot(followers_file)
    old_followings = load_snapshot(followings_file)

    added_f, removed_f = diff_sets(old_followers, followers)
    added_g, removed_g = diff_sets(old_followings, followings)

    print("\nFollowers:")
    print(f"  Current: {len(followers)}  Previous snapshot: {len(old_followers)}")
    print_changes(added_f, removed_f, old_followers, followers)

    print("\nFollowings:")
    print(f"  Current: {len(followings)}  Previous snapshot: {len(old_followings)}")
    print_changes(added_g, removed_g, old_followings, followings)

    # Save snapshots
    save_snapshot(followers, followers_file)
    save_snapshot(followings, followings_file)
    print(f"\nSnapshots saved: {followers_file}, {followings_file}")


def main_cli():
    parser = argparse.ArgumentParser(description="Combined Instagram follower/following tracker (CLI or run Flask server).")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode (one-shot or watch). If omitted the Flask server starts.")
    parser.add_argument("-s", "--sessionid", help="Instagram sessionid (cookie)")
    parser.add_argument("-u", "--username", help="Target username")
    parser.add_argument("-i", "--id", help="Target numeric user id")
    parser.add_argument("--watch", type=int, nargs="?", const=300, help="Watch mode interval seconds (optional)")
    parser.add_argument("--host", default="0.0.0.0", help="If serving Flask, host (default 0.0.0.0)")
    parser.add_argument("--port", type=int, default=5000, help="Flask port (default 5000)")
    args = parser.parse_args()

    if args.cli:
        if not args.sessionid or (not args.username and not args.id):
            parser.error("CLI mode requires --sessionid and either --username or --id")
        try:
            if args.watch:
                interval = int(args.watch)
                print(f"Entering watch mode. Interval: {interval}s. Ctrl+C to stop.")
                while True:
                    run_once_cli(args.sessionid, args.username, args.id)
                    time.sleep(interval)
            else:
                run_once_cli(args.sessionid, args.username, args.id)
        except KeyboardInterrupt:
            print("\nStopped by user.")
            sys.exit(0)
    else:
        # Start Flask server
        print(f"Starting Flask server on http://{args.host}:{args.port}")
        app.run(host=args.host, port=args.port, debug=True)


if __name__ == "__main__":
    main_cli()
_________________________________________________________________________________________________________________________________
templates ------> index.html
INDEX.HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Instagram Follower & Following Tracker</title>
    <style>
        :root{
            --bg:#fafafa;
            --card:#fff;
            --muted:#666;
            --accent:#4CAF50;
            --danger:#e74c3c;
            --pad:12px;
        }

        *{box-sizing:border-box}
        body {
            margin:0;
            font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
            background:var(--bg);
            color:#222;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
            padding:18px;
        }

        h1 { text-align:center; margin:6px 0 14px; font-size:20px; color:#222; }
        .container { max-width:980px; margin:0 auto; }

        /* Form */
        .form-card {
            background:var(--card);
            padding:var(--pad);
            border-radius:10px;
            box-shadow:0 8px 20px rgba(0,0,0,0.04);
            margin-bottom:12px;
        }
        .form-row { display:flex; gap:10px; flex-wrap:wrap; }
        .form-row input {
            flex:1 1 220px;
            padding:10px;
            border:1px solid #e6e6e6;
            border-radius:8px;
            font-size:15px;
        }
        button {
            background:var(--accent);
            color:#fff;
            border:0;
            padding:10px 14px;
            border-radius:8px;
            cursor:pointer;
            font-size:15px;
            min-width:120px;
        }
        .small { font-size:13px; color:var(--muted); margin-top:8px; }

        .error { color:var(--danger); text-align:center; margin-top:10px; }

        /* Card for results */
        .card {
            background:var(--card);
            padding:var(--pad);
            border-radius:10px;
            box-shadow:0 6px 18px rgba(0,0,0,0.03);
            margin-bottom:12px;
        }

        .row { display:flex; gap:12px; flex-wrap:wrap; align-items:baseline; }
        .stat { flex:1 1 160px; font-weight:600; }

        /* Responsive table wrapper */
        .table-responsive {
            width:100%;
            overflow-x:auto;
            -webkit-overflow-scrolling:touch;
            border-radius:8px;
            border:1px solid #efefef;
            background:#fff;
            margin-top:8px;
        }
        table {
            width:100%;
            border-collapse:collapse;
            min-width:480px; /* allows horizontal scroll on narrow screens */
        }
        th, td {
            padding:10px 12px;
            border-bottom:1px solid #f2f2f2;
            text-align:left;
            font-size:14px;
        }
        th {
            position:relative;
            background:#fbfbfb;
            font-weight:700;
            top:0;
        }
        tbody tr:hover { background:#fafafa; }

        /* Removed styling (highlight in red) */
        tr.removed { color: var(--danger); background: #fff4f4; }

        /* Account Update tag */
        .account-update-title { display:flex; align-items:center; gap:10px; }
        .badge {
            background:var(--accent); color:#fff; padding:6px 9px; border-radius:8px; font-size:13px; font-weight:700;
        }

        /* Smaller devices */
        @media (max-width:600px) {
            body { padding:12px; }
            h1 { font-size:18px; }
            .form-row input { font-size:14px; padding:9px; }
            button { font-size:14px; padding:9px; }
            th, td { padding:8px 10px; font-size:13px; }
            table { min-width:380px; }
            .stat { font-size:14px; }
        }

        /* Very small devices */
        @media (max-width:380px) {
            .form-row { flex-direction:column; }
            table { min-width:320px; }
        }

        /* Accessibility */
        .sr-only { position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Instagram Follower & Following Tracker</h1>

        <div class="form-card">
            <form id="trackForm" onsubmit="return false;">
                <div class="form-row">
                    <input id="sessionid" type="text" placeholder="Your Session ID (required)" autocomplete="off" />
                    <input id="username" type="text" placeholder="Username (optional)" autocomplete="off" />
                    <input id="user_id" type="text" placeholder="User ID (optional)" autocomplete="off" />
                    <button id="trackButton" type="button">Track</button>
                </div>
                <div class="small">Only use your own sessionid. Frequent requests may be rate-limited by Instagram.</div>
            </form>
        </div>

        <div id="errorMessage" class="error" role="alert" aria-live="assertive"></div>

        <!-- ACCOUNT UPDATE (moved to front) -->
        <div id="accountUpdateCard" class="card" style="display:none;">
            <div class="account-update-title">
                <div class="badge">Account Update</div>
                <div>
                    <div id="targetInfo" style="font-weight:700;"></div>
                    <div class="small" id="updateTime"></div>
                </div>
            </div>

            <div class="table-responsive" aria-live="polite" style="margin-top:12px;">
                <table id="accountUpdateTable" role="table" aria-describedby="updateTime">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Username</th>
                            <th>Full name</th>
                            <th>ID</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Totals & Lists -->
        <div id="resultsCard" class="card" style="display:none;">
            <div class="row" style="margin-bottom:8px;">
                <div class="stat" id="followersCount">Followers: —</div>
                <div class="stat" id="followingsCount">Followings: —</div>
            </div>

            <div style="display:flex; gap:12px; flex-wrap:wrap;">
                <div style="flex:1 1 320px; min-width:260px;">
                    <div style="font-weight:700; margin-bottom:6px;">Followers</div>
                    <div class="table-responsive">
                        <table id="followersTable" aria-label="Followers table">
                            <thead><tr><th>Username</th><th>Full name</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>

                <div style="flex:1 1 320px; min-width:260px;">
                    <div style="font-weight:700; margin-bottom:6px;">Followings</div>
                    <div class="table-responsive">
                        <table id="followingsTable" aria-label="Followings table">
                            <thead><tr><th>Username</th><th>Full name</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Not following back (full width) -->
            <div style="margin-top:12px;">
                <div style="font-weight:700; margin-bottom:6px;">Not following back (you follow them; they don't follow you)</div>
                <div class="table-responsive">
                    <table id="notFollowingBackTable" aria-label="Accounts not following back">
                        <thead><tr><th>Username</th><th>Full name</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <script>
    // Helper to create row element from columns array
    function makeRow(cols) {
        const tr = document.createElement('tr');
        for (const c of cols) {
            const td = document.createElement('td');
            td.textContent = c ?? '';
            tr.appendChild(td);
        }
        return tr;
    }

    document.getElementById('trackButton').addEventListener('click', async () => {
        // reset UI
        document.getElementById('errorMessage').textContent = '';
        document.getElementById('accountUpdateCard').style.display = 'none';
        document.getElementById('resultsCard').style.display = 'none';
        const sess = document.getElementById('sessionid').value.trim();
        const username = document.getElementById('username').value.trim();
        const user_id = document.getElementById('user_id').value.trim();

        if (!sess) {
            document.getElementById('errorMessage').textContent = 'Session ID is required';
            return;
        }

        try {
            const body = new URLSearchParams();
            body.append('sessionid', sess);
            if (username) body.append('username', username);
            if (user_id) body.append('user_id', user_id);

            const resp = await fetch('/track', { method: 'POST', body });
            if (!resp.ok) {
                // try parse JSON error
                let txt = await resp.text();
                try {
                    const js = JSON.parse(txt);
                    throw new Error(js.error || `HTTP ${resp.status}`);
                } catch (e) {
                    throw new Error(`HTTP ${resp.status}`);
                }
            }
            const data = await resp.json();

            // Account update table (combined diffs first)
            const updateTbody = document.querySelector('#accountUpdateTable tbody');
            updateTbody.innerHTML = '';

            const pushRows = (categoryName, arr) => {
                (arr || []).forEach(item => {
                    updateTbody.appendChild(makeRow([categoryName, item.username || '', item.full_name || '', item.id || '']));
                });
            };

            const diff = data.diff || {};
            pushRows('Followers added', diff.followers_added || []);
            pushRows('Followers removed', diff.followers_removed || []);
            pushRows('Followings added', diff.followings_added || []);
            pushRows('Followings removed', diff.followings_removed || []);

            // show "no changes" row if empty
            if (updateTbody.children.length === 0) {
                updateTbody.appendChild(makeRow(['No changes', '', '', '']));
            }

            // header info
            document.getElementById('targetInfo').textContent = `${data.username} (id: ${data.user_id})`;
            document.getElementById('updateTime').textContent = `Last checked: ${new Date().toLocaleString()}`;

            document.getElementById('accountUpdateCard').style.display = 'block';

            // Totals and full lists
            document.getElementById('followersCount').textContent = `Followers: ${data.followers}`;
            document.getElementById('followingsCount').textContent = `Followings: ${data.followings}`;

            // Populate followers table and mark removed in red
            const fbody = document.querySelector('#followersTable tbody');
            fbody.innerHTML = '';
            if (data.followers_data && typeof data.followers_data === 'object') {
                // iterate keys for stable output
                const keys = Object.keys(data.followers_data).sort((a,b)=>{
                    const A = (data.followers_data[a].username||'').toLowerCase();
                    const B = (data.followers_data[b].username||'').toLowerCase();
                    return A.localeCompare(B);
                });
                for (const id of keys) {
                    const u = data.followers_data[id] || {};
                    const tr = makeRow([u.username || '', u.full_name || '']);
                    if (u.removed) tr.classList.add('removed');
                    fbody.appendChild(tr);
                }
            }

            // Populate followings table and mark removed in red
            const gbody = document.querySelector('#followingsTable tbody');
            gbody.innerHTML = '';
            if (data.followings_data && typeof data.followings_data === 'object') {
                const keys = Object.keys(data.followings_data).sort((a,b)=>{
                    const A = (data.followings_data[a].username||'').toLowerCase();
                    const B = (data.followings_data[b].username||'').toLowerCase();
                    return A.localeCompare(B);
                });
                for (const id of keys) {
                    const u = data.followings_data[id] || {};
                    const tr = makeRow([u.username || '', u.full_name || '']);
                    if (u.removed) tr.classList.add('removed');
                    gbody.appendChild(tr);
                }
            }

            // Populate Not following back table (array)
            const nfbBody = document.querySelector('#notFollowingBackTable tbody');
            nfbBody.innerHTML = '';
            const nfb = data.not_following_back || [];
            if (Array.isArray(nfb) && nfb.length) {
                // sort by username
                nfb.sort((a,b)=> (a.username||'').localeCompare(b.username||''));
                for (const u of nfb) {
                    nfbBody.appendChild(makeRow([u.username || '', u.full_name || '']));
                }
            } else {
                nfbBody.appendChild(makeRow(['No accounts found', '']));
            }

            document.getElementById('resultsCard').style.display = 'block';
        } catch (err) {
            console.error(err);
            document.getElementById('errorMessage').textContent = 'Error: ' + (err.message || err);
        }
    });
    </script>
</body>
</html>
