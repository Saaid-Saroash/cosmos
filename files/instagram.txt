cd $env:USERPROFILE\Downloads
python .\insta.py -s "65860131821%3AWA3kMGqxMpJg4j%3A27%3AAYifil4vt52fcCoIGXQVuKnzdwD7d9i91OIg4_YwJg" -u saaid_sarosh77

python app.py
___________________________________________________________________________________________________________________________________
pip install requests
cd $env:USERPROFILE\Downloads
python -m venv venv
.\venv\Scripts\Activate.ps1
pip install requests
pip install flask

INSTA.PY
________________________________________________________________________________________________________________________________________
#!/usr/bin/env python3
"""
insta_follow_tracker.py
Track followers for an Instagram account and report who followed / unfollowed since last snapshot.

Usage examples:
  # Basic one-shot compare (saves snapshot if none exists)
  python insta_follow_tracker.py -s YOUR_SESSIONID -u target_username

  # Use numeric ID instead of username
  python insta_follow_tracker.py -s YOUR_SESSIONID -i 12345678

  # Watch mode: refresh every 300 seconds (5 minutes)
  python insta_follow_tracker.py -s YOUR_SESSIONID -u target_username --watch 300

Notes / Safety:
 - Use only your own sessionid (from browser cookies). Do not use others' sessionid.
 - Instagram may rate-limit or block repeated requests; use reasonable intervals in --watch.
 - This script uses unofficial endpoints that work with an authenticated session and common headers.
"""

import requests
import argparse
import json
import time
import sys
import os
from typing import Dict, Tuple, Set, Optional

USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/124.0.0.0 Safari/537.36"
)
APP_ID = "936619743392459"  # common X-IG-App-ID value used by web

SNAPSHOT_FILENAME = "followers_snapshot.json"
TIMEOUT = 15
PAGE_SIZE = 200  # request page size (max per-request, may be limited server-side)


def build_session(sessionid: str) -> requests.Session:
    s = requests.Session()
    s.headers.update({
        "User-Agent": USER_AGENT,
        "Referer": "https://www.instagram.com/",
        "X-IG-App-ID": APP_ID,
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.9",
    })
    # set cookie in session
    s.cookies.set("sessionid", sessionid, domain=".instagram.com")
    return s


# --- helper: resolve username -> user id (if username provided) ---
def resolve_userid(session: requests.Session, username: Optional[str], userid: Optional[str]) -> Optional[Tuple[str, str]]:
    """
    Returns tuple (user_id, canonical_username) or None on failure.
    If username provided, query web_profile_info endpoint to get id.
    If userid provided, attempt to fetch username via users/{id}/info/.
    """
    if username:
        url = f"https://i.instagram.com/api/v1/users/web_profile_info/?username={username}"
        try:
            r = session.get(url, timeout=TIMEOUT)
            if r.status_code == 200:
                data = r.json()
                # Typical shape: {"data": {"user": {...}}}
                user = data.get("data", {}).get("user") or data.get("user")
                if user and ("pk" in user or "id" in user):
                    uid = str(user.get("pk") or user.get("id"))
                    uname = user.get("username") or username
                    return uid, uname
        except Exception:
            pass
        # fallback to public page JSON
        url2 = f"https://www.instagram.com/{username}/?__a=1"
        try:
            r2 = session.get(url2, timeout=TIMEOUT)
            if r2.status_code == 200:
                js = r2.json()
                # possible shapes
                user = js.get("graphql", {}).get("user") or js.get("user")
                if user and ("id" in user):
                    return str(user["id"]), user.get("username", username)
        except Exception:
            pass
        print(f"❌ Failed to resolve username: {username}")
        return None

    if userid:
        # try /users/{id}/info/
        url = f"https://i.instagram.com/api/v1/users/{userid}/info/"
        try:
            r = session.get(url, timeout=TIMEOUT)
            if r.status_code == 200:
                js = r.json()
                # shape: {"user": {...}}
                u = js.get("user")
                if u and ("username" in u):
                    return str(userid), u.get("username")
        except Exception:
            pass
        # as last resort accept provided numeric id as-is
        return str(userid), str(userid)

    return None


# --- fetch full followers list using private API friendship endpoint (requires auth) ---
def fetch_all_followers(session: requests.Session, user_id: str) -> Optional[Dict[str, Dict]]:
    """
    Returns a dict mapping follower_id -> {username, full_name, pk, profile_pic_url}
    or None on error.
    Uses pagination with 'max_id' param.
    """
    followers = {}
    url_template = f"https://i.instagram.com/api/v1/friendships/{user_id}/followers/?count={PAGE_SIZE}"
    next_max_id = None
    tries = 0

    while True:
        tries += 1
        url = url_template + (f"&max_id={next_max_id}" if next_max_id else "")
        try:
            r = session.get(url, timeout=TIMEOUT)
        except Exception as e:
            print("⚠️ Network error while fetching followers:", e)
            return None

        if r.status_code == 200:
            try:
                js = r.json()
            except ValueError:
                print("⚠️ Response not JSON; got HTTP 200 but couldn't parse.")
                return None

            # typical shape: {"users":[{...}], "next_max_id": "..."}
            users = js.get("users") or js.get("users") or []
            for u in users:
                pk = str(u.get("pk") or u.get("id"))
                followers[pk] = {
                    "username": u.get("username"),
                    "full_name": u.get("full_name"),
                    "profile_pic_url": u.get("profile_pic_url") or u.get("profile_pic_url_hd"),
                }

            # pagination keys vary: next_max_id or next_max_id and more_available field
            next_max_id = js.get("next_max_id") or js.get("next_max_id") or None
            more_available = js.get("more_available")
            # if no pagination token and no more_available, break
            if not next_max_id and not more_available:
                break
            # safety: break if nothing returned to avoid infinite loop
            if not users:
                break

            # small delay to be polite and avoid rate-limits
            time.sleep(1.0)

        elif r.status_code == 429:
            print("❌ Rate limited by Instagram (HTTP 429). Back off and try later.")
            return None
        else:
            print(f"❌ Failed to fetch followers (HTTP {r.status_code}).")
            return None

        # safeguard against runaway loop
        if tries > 200:
            print("⚠️ Too many pages; aborting.")
            break

    return followers


# --- snapshot management ---
def load_snapshot(filename: str = SNAPSHOT_FILENAME) -> Dict[str, Dict]:
    if not os.path.exists(filename):
        return {}
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def save_snapshot(data: Dict[str, Dict], filename: str = SNAPSHOT_FILENAME):
    try:
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print("⚠️ Failed to save snapshot:", e)


# --- diff and pretty print ---
def diff_followers(old: Dict[str, Dict], new: Dict[str, Dict]) -> Tuple[Set[str], Set[str]]:
    old_set = set(old.keys())
    new_set = set(new.keys())
    added = new_set - old_set
    removed = old_set - new_set
    return added, removed


def print_changes(added: Set[str], removed: Set[str], old: Dict[str, Dict], new: Dict[str, Dict]):
    if not added and not removed:
        print("No changes since last snapshot.")
        return

    if added:
        print(f"\n➕ New followers ({len(added)}):")
        for pk in sorted(added):
            info = new.get(pk, {})
            print(f"  - {info.get('username') or '(unknown)'} (id: {pk}) - {info.get('full_name') or ''}")
    if removed:
        print(f"\n➖ Lost followers ({len(removed)}):")
        for pk in sorted(removed):
            info = old.get(pk, {})
            print(f"  - {info.get('username') or '(unknown)'} (id: {pk}) - {info.get('full_name') or ''}")


# --- main flow ---
def run_once(sessionid: str, username: Optional[str], userid: Optional[str], snapshot_file: str):
    session = build_session(sessionid)
    resolved = resolve_userid(session, username, userid)
    if not resolved:
        print("❌ Could not resolve target account. Check username/id and session permissions.")
        return
    target_uid, canonical_username = resolved
    print(f"Fetching followers for {canonical_username} (id {target_uid}) ... (may take a while)")

    new_followers = fetch_all_followers(session, target_uid)
    if new_followers is None:
        print("❌ Failed to fetch followers.")
        return

    old_snapshot = load_snapshot(snapshot_file)
    added, removed = diff_followers(old_snapshot, new_followers)

    print_changes(added, removed, old_snapshot, new_followers)

    # print totals
    print(f"\nTotal current followers fetched: {len(new_followers)}")
    if old_snapshot:
        print(f"Previous snapshot size: {len(old_snapshot)}")

    # Save new snapshot
    save_snapshot(new_followers, snapshot_file)
    print(f"✅ Snapshot saved to {snapshot_file}")


def main():
    parser = argparse.ArgumentParser(description="Track Instagram followers and show who followed/unfollowed since last snapshot.")
    parser.add_argument("-s", "--sessionid", required=True, help="Your Instagram sessionid cookie (use your own)")
    parser.add_argument("-u", "--username", help="Target Instagram username (e.g., instagram)")
    parser.add_argument("-i", "--id", help="Target Instagram numeric id")
    parser.add_argument("--snapshot", default=SNAPSHOT_FILENAME, help="Snapshot filename (default: followers_snapshot.json)")
    parser.add_argument("--watch", type=int, nargs="?", const=300, help="Optional watch mode: integer interval in seconds (default 300). Runs repeatedly until Ctrl+C.")
    args = parser.parse_args()

    if not args.username and not args.id:
        print("❌ Provide either -u username or -i numeric id.")
        sys.exit(1)

    try:
        if args.watch:
            interval = int(args.watch)
            print(f"Entering watch mode. Refresh interval: {interval}s. Ctrl+C to stop.")
            while True:
                run_once(args.sessionid, args.username, args.id, args.snapshot)
                time.sleep(interval)
        else:
            run_once(args.sessionid, args.username, args.id, args.snapshot)
    except KeyboardInterrupt:
        print("\nStopped by user. Exiting.")
        sys.exit(0)


if __name__ == "__main__":
    main()
_________________________________________________________________________________________________________________________________
APP.PY

#!/usr/bin/env python3
"""
Combined Flask + CLI Instagram follower/following tracker.
- Run as web server (default): python app.py
- Run CLI one-shot: python app.py --cli -s SESSIONID -u username
- Run CLI watch mode: python app.py --cli -s SESSIONID -u username --watch 300

Outputs:
 - Serves a simple HTML UI at GET / (templates/index.html)
 - POST /track accepts form-data: sessionid, username, user_id and returns JSON with:
   followers, followings, followers_data, followings_data, added/removed lists since last snapshot.
"""
import argparse
import json
import os
import sys
import time
from typing import Dict, Optional, Tuple, Set

import requests
from flask import Flask, render_template, request, jsonify

# ----- Configuration -----
USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/124.0.0.0 Safari/537.36"
)
APP_ID = "936619743392459"
TIMEOUT = 15
PAGE_SIZE = 200
RATE_SLEEP = 1.0  # seconds between pages
SNAPSHOT_DIR = "snapshots"
if not os.path.exists(SNAPSHOT_DIR):
    os.makedirs(SNAPSHOT_DIR)

# ----- Flask app -----
app = Flask(__name__, template_folder="templates")


def build_session(sessionid: str) -> requests.Session:
    s = requests.Session()
    s.headers.update({
        "User-Agent": USER_AGENT,
        "Referer": "https://www.instagram.com/",
        "X-IG-App-ID": APP_ID,
        "Accept": "/",
        "Accept-Language": "en-US,en;q=0.9",
    })
    # set cookie (authenticated session)
    s.cookies.set("sessionid", sessionid, domain=".instagram.com")
    return s


def resolve_userid(session: requests.Session, username: Optional[str], userid: Optional[str]) -> Optional[Tuple[str, str]]:
    """
    Returns (user_id, canonical_username) or None.
    Tries i.instagram.com web_profile_info first then public JSON fallback.
    """
    if username:
        url = f"https://i.instagram.com/api/v1/users/web_profile_info/?username={username}"
        try:
            r = session.get(url, timeout=TIMEOUT)
            if r.status_code == 200:
                data = r.json()
                user = data.get("data", {}).get("user") or data.get("user")
                if user and ("pk" in user or "id" in user):
                    uid = str(user.get("pk") or user.get("id"))
                    uname = user.get("username") or username
                    return uid, uname
        except Exception:
            pass
        # fallback: public page json
        try:
            r2 = session.get(f"https://www.instagram.com/{username}/?__a=1", timeout=TIMEOUT)
            if r2.status_code == 200:
                js = r2.json()
                user = js.get("graphql", {}).get("user") or js.get("user")
                if user and ("id" in user):
                    return str(user["id"]), user.get("username", username)
        except Exception:
            pass
        return None

    if userid:
        # try i.instagram.com info endpoint
        try:
            r = session.get(f"https://i.instagram.com/api/v1/users/{userid}/info/", timeout=TIMEOUT)
            if r.status_code == 200:
                js = r.json()
                u = js.get("user")
                if u and ("username" in u):
                    return str(userid), u.get("username")
        except Exception:
            pass
        # last resort: accept numeric id and use as username placeholder
        return str(userid), str(userid)

    return None


def fetch_relationship_data(session: requests.Session, user_id: str, relationship: str) -> Optional[Dict[str, Dict]]:
    """
    relationship: "followers" or "following" (followings)
    Returns dict mapping user_id -> {username, full_name, profile_pic_url}
    """
    data = {}
    assert relationship in ("followers", "following", "followings", "followed-by")
    # use expected endpoint shape
    endpoint_name = "followers" if relationship.startswith("follower") else "following"
    url_template = f"https://i.instagram.com/api/v1/friendships/{user_id}/{endpoint_name}/?count={PAGE_SIZE}"
    next_max_id = None
    tries = 0

    while True:
        tries += 1
        url = url_template + (f"&max_id={next_max_id}" if next_max_id else "")
        try:
            r = session.get(url, timeout=TIMEOUT)
        except Exception as e:
            print(f"Network error fetching {relationship}: {e}")
            return None

        if r.status_code == 200:
            try:
                js = r.json()
            except ValueError:
                print("Non-JSON response while fetching relationships.")
                return None

            users = js.get("users") or js.get("items") or []
            for u in users:
                pk = str(u.get("pk") or u.get("id"))
                data[pk] = {
                    "username": u.get("username"),
                    "full_name": u.get("full_name") or "",
                    "profile_pic_url": u.get("profile_pic_url") or u.get("profile_pic_url_hd") or "",
                }

            # pagination tokens vary between endpoints
            next_max_id = js.get("next_max_id") or js.get("next_cursor") or js.get("next_max_id")
            more_available = js.get("more_available") or js.get("more")
            if not next_max_id and not more_available:
                break

            if not users:
                break

            time.sleep(RATE_SLEEP)

        elif r.status_code == 429:
            print("Rate limited (429). Back off and try later.")
            return None
        else:
            print(f"Failed to fetch {relationship} (HTTP {r.status_code}).")
            return None

        if tries > 500:
            print("Too many pages, aborting.")
            break

    return data


def snapshot_filename(kind: str, target_uid: str) -> str:
    # kind = 'followers' or 'followings'
    return os.path.join(SNAPSHOT_DIR, f"{kind}_{target_uid}.json")


def load_snapshot(filename: str) -> Dict[str, Dict]:
    if not os.path.exists(filename):
        return {}
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def save_snapshot(data: Dict[str, Dict], filename: str):
    try:
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"Failed to save snapshot {filename}: {e}")


def diff_sets(old: Dict[str, Dict], new: Dict[str, Dict]):
    old_set = set(old.keys())
    new_set = set(new.keys())
    added = sorted(list(new_set - old_set))
    removed = sorted(list(old_set - new_set))
    return added, removed


# --- Flask routes ---
@app.route("/")
def index():
    return render_template("index.html")


@app.route("/track", methods=["POST"])
def track():
    sessionid = request.form.get("sessionid")
    username = request.form.get("username")
    user_id = request.form.get("user_id")

    if not sessionid:
        return jsonify({"error": "Session ID is required"}), 400
    if not username and not user_id:
        return jsonify({"error": "Provide either username or user_id"}), 400

    session = build_session(sessionid)
    resolved = resolve_userid(session, username, user_id)
    if not resolved:
        return jsonify({"error": "Could not resolve user (check username/id or session permissions)"}), 400

    target_uid, canonical_username = resolved

    followers = fetch_relationship_data(session, target_uid, "followers")
    followings = fetch_relationship_data(session, target_uid, "following")

    if followers is None or followings is None:
        return jsonify({"error": "Failed to fetch data (possibly rate-limited or invalid session)"}), 500

    # load previous snapshots to compute diff
    followers_file = snapshot_filename("followers", target_uid)
    followings_file = snapshot_filename("followings", target_uid)
    old_followers = load_snapshot(followers_file)
    old_followings = load_snapshot(followings_file)

    added_followers, removed_followers = diff_sets(old_followers, followers)
    added_followings, removed_followings = diff_sets(old_followings, followings)

    # save new snapshots
    save_snapshot(followers, followers_file)
    save_snapshot(followings, followings_file)

    # build compact diff info
    def compact(list_ids, src):
        return [{"id": i, "username": src.get(i, {}).get("username"), "full_name": src.get(i, {}).get("full_name")} for i in list_ids]

    return jsonify({
        "username": canonical_username,
        "user_id": target_uid,
        "followers": len(followers),
        "followings": len(followings),
        "followers_data": followers,
        "followings_data": followings,
        "diff": {
            "followers_added": compact(added_followers, followers),
            "followers_removed": compact(removed_followers, old_followers),
            "followings_added": compact(added_followings, followings),
            "followings_removed": compact(removed_followings, old_followings)
        }
    })


# --- CLI utilities (reuse above functions) ---
def print_changes(added: Set[str], removed: Set[str], old: Dict[str, Dict], new: Dict[str, Dict]):
    if not added and not removed:
        print("No changes since last snapshot.")
        return
    if added:
        print(f"\n➕ New ({len(added)}):")
        for pk in sorted(added):
            info = new.get(pk, {})
            print(f"  - {info.get('username') or '(unknown)'} (id: {pk}) {info.get('full_name') or ''}")
    if removed:
        print(f"\n➖ Removed ({len(removed)}):")
        for pk in sorted(removed):
            info = old.get(pk, {})
            print(f"  - {info.get('username') or '(unknown)'} (id: {pk}) {info.get('full_name') or ''}")


def run_once_cli(sessionid: str, username: Optional[str], userid: Optional[str], snapshot_prefix: Optional[str] = None):
    session = build_session(sessionid)
    resolved = resolve_userid(session, username, userid)
    if not resolved:
        print("Could not resolve target account. Check username/id and session permissions.")
        return
    target_uid, canonical_username = resolved
    print(f"Fetching for {canonical_username} (id {target_uid}) ...")

    followers = fetch_relationship_data(session, target_uid, "followers")
    followings = fetch_relationship_data(session, target_uid, "following")
    if followers is None or followings is None:
        print("Failed to fetch (rate-limited/invalid session).")
        return

    followers_file = snapshot_filename("followers", target_uid)
    followings_file = snapshot_filename("followings", target_uid)
    old_followers = load_snapshot(followers_file)
    old_followings = load_snapshot(followings_file)

    added_f, removed_f = diff_sets(old_followers, followers)
    added_g, removed_g = diff_sets(old_followings, followings)

    print("\nFollowers:")
    print(f"  Current: {len(followers)}  Previous snapshot: {len(old_followers)}")
    print_changes(added_f, removed_f, old_followers, followers)

    print("\nFollowings:")
    print(f"  Current: {len(followings)}  Previous snapshot: {len(old_followings)}")
    print_changes(added_g, removed_g, old_followings, followings)

    # Save snapshots
    save_snapshot(followers, followers_file)
    save_snapshot(followings, followings_file)
    print(f"\nSnapshots saved: {followers_file}, {followings_file}")


def main_cli():
    parser = argparse.ArgumentParser(description="Combined Instagram follower/following tracker (CLI or run Flask server).")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode (one-shot or watch). If omitted the Flask server starts.")
    parser.add_argument("-s", "--sessionid", help="Instagram sessionid (cookie)")
    parser.add_argument("-u", "--username", help="Target username")
    parser.add_argument("-i", "--id", help="Target numeric user id")
    parser.add_argument("--watch", type=int, nargs="?", const=300, help="Watch mode interval seconds (optional)")
    parser.add_argument("--host", default="0.0.0.0", help="If serving Flask, host (default 0.0.0.0)")
    parser.add_argument("--port", type=int, default=5000, help="Flask port (default 5000)")
    args = parser.parse_args()

    if args.cli:
        if not args.sessionid or (not args.username and not args.id):
            parser.error("CLI mode requires --sessionid and either --username or --id")
        try:
            if args.watch:
                interval = int(args.watch)
                print(f"Entering watch mode. Interval: {interval}s. Ctrl+C to stop.")
                while True:
                    run_once_cli(args.sessionid, args.username, args.id)
                    time.sleep(interval)
            else:
                run_once_cli(args.sessionid, args.username, args.id)
        except KeyboardInterrupt:
            print("\nStopped by user.")
            sys.exit(0)
    else:
        # Start Flask server
        print(f"Starting Flask server on http://{args.host}:{args.port}")
        app.run(host=args.host, port=args.port, debug=True)


if __name__ == "__main__":
    main_cli()
